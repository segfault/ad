// autogenerated, do not edit!
package vm

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"io"
	"log"
	"strconv"
	"strings"
)

func Compile(f io.Reader) Program {
	w := new(bytes.Buffer)
	p := Program{}
	s := bufio.NewScanner(f)
	var fields []string
	tmp := make([]byte, 20)
	putOp := func(o VmOp) {
		n := binary.PutUvarint(tmp, uint64(o))
		w.Write(tmp[:n])
	}
	putInt := func(i int) uint64 {
		v, err := strconv.ParseUint(fields[i], 10, 64)
		check(err)
		n := binary.PutUvarint(tmp, v)
		w.Write(tmp[:n])
		return v
	}
	putFloat := func(i int) {
		v, err := strconv.ParseFloat(fields[i], 64)
		check(err)
		binary.Write(w, order, v)
	}
	for s.Scan() {
		line := s.Text()
		line = strings.TrimSpace(strings.ToLower(line))
		if len(line) == 0 {
			continue
		}
		if p.Name == "" && line[0] == '#' {
			p.Name = strings.TrimSpace(line[1:])
			continue
		} else if line[0] == '#' {
			continue
		}
		fields = strings.Fields(line)
		switch fields[0] {
		case "halt":
			putOp(Halt)
		case "registers":
			putOp(Registers)
			p.Registers = putInt(1)
		case "literal":
			putOp(Literal)
			putInt(1)
			putFloat(2)
		case "outputs":
			putOp(Outputs)
			p.Outputs = putInt(1)
		case "inputs":
			putOp(Inputs)
			p.Inputs = putInt(1)
		case "setoutput":
			putOp(SetOutput)
			putInt(1)
			putInt(2)
		case "multiply":
			putOp(Multiply)
			putInt(1)
			putInt(2)
			putInt(3)
		case "divide":
			putOp(Divide)
			putInt(1)
			putInt(2)
			putInt(3)
		case "subtract":
			putOp(Subtract)
			putInt(1)
			putInt(2)
			putInt(3)
		case "add":
			putOp(Add)
			putInt(1)
			putInt(2)
			putInt(3)
		case "log":
			putOp(Log)
			putInt(1)
			putInt(2)
		case "log10":
			putOp(Log10)
			putInt(1)
			putInt(2)
		default:
			log.Fatalf("unknown opcode: %s", fields[0])
		}
	}
	check(s.Err())
	p.Code = w.Bytes()
	return p
}
