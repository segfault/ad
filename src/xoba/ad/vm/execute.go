// autogenerated, do not edit!
package vm

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"math"
)

func Execute(p Program, model, in, out []float64) (err error) {
	if len(out) == 0 {
		return fmt.Errorf("needs at least one output")
	}
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("recovered from: %v", r)
		}
	}()
	fmt.Printf("%d byte program %v\n", len(p.Code), p)
	r := bytes.NewReader(p.Code)
	one := func() uint64 {
		a, err := binary.ReadUvarint(r)
		check(err)
		return a
	}
	two := func() (uint64, uint64) {
		a, err := binary.ReadUvarint(r)
		check(err)
		b, err := binary.ReadUvarint(r)
		check(err)
		return a, b
	}
	three := func() (uint64, uint64, uint64) {
		a, err := binary.ReadUvarint(r)
		check(err)
		b, err := binary.ReadUvarint(r)
		check(err)
		c, err := binary.ReadUvarint(r)
		check(err)
		return a, b, c
	}
	var registers []float64

Loop:
	for {
		c, err := binary.ReadUvarint(r)
		check(err)
		fmt.Printf("op = %s\n", VmOp(c))
		// general rules:
		// locations stored first, values later
		// source first, destination after
		switch VmOp(c) {
		case Literal: // store a literal to register
			loc := one()
			var lit float64
			binary.Read(r, order, &lit)
			registers[loc] = lit
		case Registers:
			registers = make([]float64, one())
		case Inputs:
			n := one()
			if len(in) < int(n) {
				return fmt.Errorf("needs at least %d inputs; has %d", n, len(in))
			}
		case Models:
			n := one()
			if len(model) < int(n) {
				return fmt.Errorf("needs at least %d model dimensions; has %d", n, len(model))
			}
		case Outputs:
			n := one()
			if len(out) < int(n) {
				return fmt.Errorf("needs at least %d outputs; has %d", n, len(out))
			}
		case SetOutput: // set output from register
			src, dest := two()
			out[dest] = registers[src]
		case GetInput: // set register from input
			src, dest := two()
			registers[dest] = in[src]
		case GetModel: // set register from model
			src, dest := two()
			registers[dest] = model[src]
		case Halt:
			break Loop

		case Abs:
			src, dest := two()
			registers[dest] = math.Abs(registers[src])
		case Acos:
			src, dest := two()
			registers[dest] = math.Acos(registers[src])
		case Asin:
			src, dest := two()
			registers[dest] = math.Asin(registers[src])
		case Atan:
			src, dest := two()
			registers[dest] = math.Atan(registers[src])
		case Cos:
			src, dest := two()
			registers[dest] = math.Cos(registers[src])
		case Cosh:
			src, dest := two()
			registers[dest] = math.Cosh(registers[src])
		case Exp:
			src, dest := two()
			registers[dest] = math.Exp(registers[src])
		case Exp10:
			src, dest := two()
			registers[dest] = exp10(registers[src])
		case Exp2:
			src, dest := two()
			registers[dest] = math.Exp2(registers[src])
		case Log:
			src, dest := two()
			registers[dest] = math.Log(registers[src])
		case Log10:
			src, dest := two()
			registers[dest] = math.Log10(registers[src])
		case Log2:
			src, dest := two()
			registers[dest] = math.Log2(registers[src])
		case Sin:
			src, dest := two()
			registers[dest] = math.Sin(registers[src])
		case Sinh:
			src, dest := two()
			registers[dest] = math.Sinh(registers[src])
		case Sqrt:
			src, dest := two()
			registers[dest] = math.Sqrt(registers[src])
		case Tan:
			src, dest := two()
			registers[dest] = math.Tan(registers[src])
		case Tanh:
			src, dest := two()
			registers[dest] = math.Tanh(registers[src])

		case Add:
			a, b, dest := three()
			registers[dest] = registers[a] + registers[b]
		case Divide:
			a, b, dest := three()
			registers[dest] = registers[a] / registers[b]
		case Multiply:
			a, b, dest := three()
			registers[dest] = registers[a] * registers[b]
		case Subtract:
			a, b, dest := three()
			registers[dest] = registers[a] - registers[b]

		case Pow:
			a, b, dest := three()
			registers[dest] = math.Pow(registers[a], registers[b])

		default:
			return fmt.Errorf("unhandled op %s", VmOp(c))
		}
	}
	return
}
