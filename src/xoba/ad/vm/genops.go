package vm

import (
	"fmt"
	"os"
	"strings"
	"text/template"
	"xoba/ad/defs"
)

type OpDef struct {
	Name        string
	Description string `json:",omitempty"`
	Signature   string `json:",omitempty"`
	Type        string `json:",omitempty"`
	Runtime     string `json:",omitempty"`
}

var (
	_twos map[VmOp]string = map[VmOp]string{
		Abs:   "math.Abs",
		Acos:  "math.Acos",
		Asin:  "math.Asin",
		Atan:  "math.Atan",
		Cos:   "math.Cos",
		Cosh:  "math.Cosh",
		Exp:   "math.Exp",
		Exp10: "exp10",
		Exp2:  "math.Exp2",
		Log:   "math.Log",
		Log10: "math.Log10",
		Log2:  "math.Log2",
		Sin:   "math.Sin",
		Sinh:  "math.Sinh",
		Sqrt:  "math.Sqrt",
		Tan:   "math.Tan",
		Tanh:  "math.Tanh",
	}
	_threes map[VmOp]string = map[VmOp]string{
		Add:      "+",
		Multiply: "*",
		Divide:   "/",
		Subtract: "-",
	}
	_twoArgFuncs map[VmOp]string = map[VmOp]string{
		Pow: "math.Pow",
	}
	_ops map[string]string = map[string]string{
		"Abs":       "absolute value",
		"Acos":      "",
		"Add":       "",
		"Asin":      "",
		"Atan":      "",
		"Cos":       "",
		"Cosh":      "",
		"Divide":    "",
		"Exp":       "",
		"Exp10":     "10^x",
		"Exp2":      "2^x",
		"Halt":      "",
		"Inputs":    "validate input dimension is large enough",
		"Models":    "validate model dimension is large enough",
		"Literal":   "",
		"Log":       "",
		"Log10":     "",
		"Log2":      "",
		"Multiply":  "",
		"Outputs":   "validate output dimension is large enough",
		"Pow":       "",
		"Registers": "1 argument, sets the number of registers",
		"GetInput":  "copy input to register",
		"GetModel":  "copy model to register",
		"SetOutput": "copy register to output",
		"Sin":       "",
		"Sinh":      "",
		"Sqrt":      "",
		"Subtract":  "",
		"Tan":       "",
		"Tanh":      "",
	}
	_sigs map[string]Signature = map[string]Signature{
		"Abs":             One,
		"Acos":            One,
		"Add":             Two,
		"Asin":            One,
		"Atan":            One,
		"Cos":             One,
		"Cosh":            One,
		"Divide":          Two,
		"Exp":             One,
		"Exp10":           One,
		"Exp2":            One,
		"Halt":            None,
		"HaltIfDmodelNil": None,
		"Inputs":          Integer, // specify dimension of input
		"Literal":         "DR,F",  // destination register, floating-point value
		"Log":             One,
		"Log10":           One,
		"Log2":            One,
		"Multiply":        Two,
		"Outputs":         Integer, // specify dimension of output
		"Pow":             Two,
		"Registers":       Integer, // specify number of registers
		"SetOutput":       "SR,DI", // source register, destination index
		"GetInput":        "SI,DR", // source index, destination register
		"Sin":             One,
		"Sinh":            One,
		"Sqrt":            One,
		"Subtract":        Two,
		"Tan":             One,
		"Tanh":            One,
	}
)

func OrganizeOps(args []string) {
	var list []OpDef
	for _, op := range AllOps {
		name := op.String()
		if strings.HasPrefix(name, "D_") {
			continue
		}
		var t, rt string
		switch {
		case _twos[op] != "":
			t = "twos"
			rt = _twos[op]
		case _threes[op] != "":
			t = "threes"
			rt = _threes[op]
		case _twoArgFuncs[op] != "":
			t = "funcs2"
			rt = _twoArgFuncs[op]
		}
		d := OpDef{
			Name:        name,
			Description: _ops[name],
			Signature:   string(_sigs[name]),
			Type:        t,
			Runtime:     rt,
		}
		list = append(list, d)
	}
	f, err := os.Create("opdefs.go")
	check(err)
	fmt.Fprintln(f, "package vm")
	fmt.Fprintln(f, "var Defs []OpDef = []OpDef{")
	for _, d := range list {
		def := fmt.Sprintf("%#v", d)
		fmt.Fprintf(f, "%s,\n", def[3:])
	}
	fmt.Fprintln(f, "}")
	f.Close()
	check(defs.Gofmt("opdefs.go"))
}

const ops_source = "ops.go"

type Signature string

const (
	One     Signature = "SR,DR"    // source register -> destination register
	Two               = "SR,SR,DR" // source registers -> destination register
	None              = "N/A"      // no arguments
	Integer           = "I"        // an integer
)

func (o VmOp) ToLower() string {
	return strings.ToLower(o.String())
}

func GenOps(args []string) {
	f, err := os.Create(ops_source)
	check(err)
	t := template.Must(template.New(ops_source).Parse(`// autogenerated, do not edit!
package vm

type VmOp uint64

// {{.comment}}
const (
	_ VmOp = iota

{{range $op,$desc := .ops}}{{$op}} // {{$desc}}
{{end}}
)

var AllOps []VmOp = []VmOp{
{{range $op,$desc := .ops}}{{$op}},
{{end}}
}

func (o VmOp) String() string {
	switch o {
{{range $op,$desc := .ops}}case {{$op}}:
return "{{$op}}"
{{end}}}
panic("illegal state")
}
`))

	ops := make(map[string]string)
	derivs := make(map[string]string)

	for _, op := range Defs {
		name := op.Name
		ops[name] = op.Description
		switch op.Type {
		case "twos":
			ops[fmt.Sprintf("D_%s_D0", name)] = fmt.Sprintf("derivative of first argument of %s", name)
		case "threes", "funcs2":
			ops[fmt.Sprintf("D_%s_D0", name)] = fmt.Sprintf("derivative of first argument of %s", name)
			ops[fmt.Sprintf("D_%s_D1", name)] = fmt.Sprintf("derivative of second argument of %s", name)
		}
	}
	t.Execute(f, map[string]interface{}{
		"ops":     ops,
		"derivs":  derivs,
		"comment": fmt.Sprintf("%d total assignments (VmOp âˆˆ [0..%d])", len(ops)+1, len(ops)),
	})
	f.Close()
	defs.Gofmt(ops_source)
}
