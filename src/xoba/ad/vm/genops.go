package vm

import (
	"os"
	"sort"
	"text/template"
	"xoba/ad/defs"
)

const ops_source = "ops.go"

var ops map[string]string = map[string]string{
	"Abs":             "",
	"Acos":            "",
	"Add":             "",
	"Asin":            "",
	"Atan":            "",
	"Cos":             "",
	"Cosh":            "",
	"Divide":          "",
	"Exp":             "",
	"Exp10":           "",
	"Exp2":            "",
	"Halt":            "",
	"HaltIfDmodelNil": "",
	"Inputs":          "",
	"Literal":         "",
	"Log":             "",
	"Log10":           "",
	"Log2":            "",
	"Multiply":        "",
	"Outputs":         "",
	"Pow":             "",
	"Registers":       "",
	"SetScalarOutput": "",
	"SetVectorOutput": "",
	"Sin":             "",
	"Sinh":            "",
	"Sqrt":            "",
	"Subtract":        "",
	"Tan":             "",
	"Tanh":            "",
}

func GenOps(args []string) {
	f, err := os.Create(ops_source)
	check(err)
	t := template.Must(template.New(ops_source).Parse(`// autogenerated, do not edit!
package vm

type VmOp uint64

const (
	_ VmOp = iota

{{range .ops}}{{.}}
{{end}}
)

func (o VmOp) String() string {
	switch o {
{{range .ops}}case {{.}}:
return "{{.}}"
{{end}}}
panic("illegal state")
}

// the following can be copied over to "ops" var (self-reproduction)
/*
var ops map[string]string = map[string]string{
{{$op,$desc := range .ops}}"{{.$op}" :"{{$desc}}",
{{end}}}
*/

// the following can serve as template for single-arg funcs
/*

	twos := map[VmOp]string{
{{range .ops}}{{.}}:"math.{{.}}",
{{end}}
}
*/

`))

	var list []string
	for op := range ops {
		list = append(list, op)
	}
	sort.Strings(list)

	t.Execute(f, map[string]interface{}{
		"ops": list,
	})
	f.Close()
	defs.Gofmt(ops_source)
}
