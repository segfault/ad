package vm

import (
	"fmt"
	"os"
	"strings"
	"text/template"
	"xoba/ad/defs"
)

type OpDef struct {
	Name        string
	Description string `json:",omitempty"`
	Signature   string `json:",omitempty"`
	Type        string `json:",omitempty"`
	Runtime     string `json:",omitempty"`
}

func OrganizeOps(args []string) {
	var list []OpDef
	for _, op := range AllOps {
		name := op.String()
		var t, rt string
		switch {
		case twos[op] != "":
			t = "twos"
			rt = twos[op]
		case threes[op] != "":
			t = "threes"
			rt = threes[op]
		case twoArgFuncs[op] != "":
			t = "funcs2"
			rt = twoArgFuncs[op]
		}
		d := OpDef{
			Name:        name,
			Description: ops[name],
			Signature:   string(sigs[name]),
			Type:        t,
			Runtime:     rt,
		}
		list = append(list, d)
		continue
		switch d.Type {
		case "threes":
			copy := d
			copy.Type = "twos"
			copy.Name = fmt.Sprintf("D%sD0", d.Name)
			copy.Runtime = "dmultiplyd0"
			list = append(list, copy)
			copy.Name = fmt.Sprintf("D%sD1", d.Name)
			copy.Runtime = "dmultiplyd1"
			list = append(list, copy)
		}
	}
	f, err := os.Create("opdefs.go")
	check(err)
	fmt.Fprintln(f, "package vm")
	fmt.Fprintln(f, "var Defs []OpDef = []OpDef{")
	for _, d := range list {
		def := fmt.Sprintf("%#v", d)
		fmt.Fprintf(f, "%s,\n", def[3:])
	}
	fmt.Fprintln(f, "}")
	f.Close()
	check(defs.Gofmt("opdefs.go"))
}

const ops_source = "ops.go"

var ops map[string]string = map[string]string{
	"Abs":       "absolute value",
	"Acos":      "",
	"Add":       "",
	"Asin":      "",
	"Atan":      "",
	"Cos":       "",
	"Cosh":      "",
	"Divide":    "",
	"Exp":       "",
	"Exp10":     "10^x",
	"Exp2":      "2^x",
	"Halt":      "",
	"Inputs":    "validate input dimension is large enough",
	"Models":    "validate model dimension is large enough",
	"Literal":   "",
	"Log":       "",
	"Log10":     "",
	"Log2":      "",
	"Multiply":  "",
	"Outputs":   "validate output dimension is large enough",
	"Pow":       "",
	"Registers": "1 argument, sets the number of registers",
	"GetInput":  "copy input to register",
	"GetModel":  "copy model to register",
	"SetOutput": "copy register to output",
	"Sin":       "",
	"Sinh":      "",
	"Sqrt":      "",
	"Subtract":  "",
	"Tan":       "",
	"Tanh":      "",
}

type Signature string

const (
	One     Signature = "SR,DR"    // source register -> destination register
	Two               = "SR,SR,DR" // source registers -> destination register
	None              = "N/A"      // no arguments
	Integer           = "I"        // an integer
)

func (o VmOp) ToLower() string {
	return strings.ToLower(o.String())
}

var sigs map[string]Signature = map[string]Signature{
	"Abs":             One,
	"Acos":            One,
	"Add":             Two,
	"Asin":            One,
	"Atan":            One,
	"Cos":             One,
	"Cosh":            One,
	"Divide":          Two,
	"Exp":             One,
	"Exp10":           One,
	"Exp2":            One,
	"Halt":            None,
	"HaltIfDmodelNil": None,
	"Inputs":          Integer, // specify dimension of input
	"Literal":         "DR,F",  // destination register, floating-point value
	"Log":             One,
	"Log10":           One,
	"Log2":            One,
	"Multiply":        Two,
	"Outputs":         Integer, // specify dimension of output
	"Pow":             Two,
	"Registers":       Integer, // specify number of registers
	"SetOutput":       "SR,DI", // source register, destination index
	"GetInput":        "SI,DR", // source index, destination register
	"Sin":             One,
	"Sinh":            One,
	"Sqrt":            One,
	"Subtract":        Two,
	"Tan":             One,
	"Tanh":            One,
}

func GenOps(args []string) {
	f, err := os.Create(ops_source)
	check(err)
	t := template.Must(template.New(ops_source).Parse(`// autogenerated, do not edit!
package vm

type VmOp uint64

const (
	_ VmOp = iota

{{range $op,$desc := .ops}}{{$op}} // {{$desc}}
{{end}}
)

var AllOps []VmOp = []VmOp{
{{range $op,$desc := .ops}}{{$op}},
{{end}}
}

func (o VmOp) String() string {
	switch o {
{{range $op,$desc := .ops}}case {{$op}}:
return "{{$op}}"
{{end}}}
panic("illegal state")
}

`))

	t.Execute(f, map[string]interface{}{
		"ops": ops,
	})
	f.Close()
	defs.Gofmt(ops_source)
}
